---

layout: post
title: "分布式系统一致性问题浅析"

---

{% include JB/setup %}

在集中式系统中，通过本地数据库事务可以很容易的保证系统状态转换的一致性（即ACID中的C，这里的系统状态指存储在数据库中的数据，每个本地事务的提交使得系统从一个状态转换到另一个状态）。但是在分布式系统中，很可能每个系统都有自己独立的数据库保存自己的状态，想要保证两个系统甚至多个系统之间状态转换的一致性则不是那么容易。

考虑最简单的场景，系统A从状态a1转换到a2的过程中，需要嵌入对系统B的一个RPC调用（任何通过网络传输的远程服务调用），并且该调用如果成功会导致系统B的状态从b1转换到b2，此时如何保证两个系统间的一致性（即要么两个系统都完成(a1, b1) -> (a2, b2)，要么两个系统都不转换）？举个简单的例子，例如系统A是支付系统，系统B是物流系统，如果客户在系统A中支付成功，则必须同时保证调用物流系统B进行发货，如果支付失败，物流系统当然也必须保证不发货。

<!--more-->

根据CAP定理，在分布式环境中系统可用性不受影响的情况下同时保证强一致性是不可能的，因此这里只考虑最终一致性，即允许在有限的时间内系统处于不一致的状态。

首先来看一下一次RPC调用可能发生哪些事情：

1. A发送服务请求数据包
2. B接收服务请求数据包
3. B进行内部处理
4. B发送处理结果数据包
5. A接收处理结果数据包

[![RPC调用]({{ site.url }}/assets/distributed_transaction_1/rpc.png)]({{ site.url }}/assets/distributed_transaction_1/rpc.png)

在上述所有步骤都正常且不超时的情况下，A会收到B的处理结果，并且直接根据处理结果提交或回滚本地事务即可。

但是事实上，上述任何步骤都可能出现问题，因此从A的角度出发，有且仅有如下可能分支：

1. A发送服务请求数据包出错
2. A发送服务请求数据包成功，并且：  
2.1 A在超时时间内收到1次或n次处理结果数据包  
2.2 A在超时时间内未收到请求

注意，这里假定：

1. 网络中没有拜占庭类型的错误，即数据包不会在网络中被篡改，要么丢失要么原样投递
2. A在超时时间之后收到的请求会被直接丢弃

考虑一下上述场景，不难发现，1和2.1都很好处理（1直接回滚，2.1根据B的处理结果进行提交或回滚即可，如果认为B的响应数据包可能重复投递则需要注意额外处理幂等以及并发）；比较麻烦的是2.2，此时A在超时时间内并未收到B的响应，此时有且仅有如下几种可能：

1. B未收到请求数据包
2. B收到了请求数据包  
2.1 B处理成功，并且发送了响应数据包  
2.2 B收到数据包之后发生了错误（包含任何错误）

分支有点多，但是总结起来很简单，即

> 当A成功发送了请求，但是等待B的响应超时时，B可能处于任意状态（根本没收到 or 收到了处理失败 or 收到了处理成功 or ...），此时A实际上没有办法知道B的真实状态，因此也就无法知道自己应该回滚事务还是提交事务。

此时就算A进行重试，会产生同样的分支，即无论重试多少次，永远有概率收不到B的响应，则对于A来说B可能处于任意状态。因此，这种简单的调用是无法保证本地事务和RPC调用的（最终）一致性的，必须使用其他方法，而最常用的一种即为两阶段协议。

（未完待续）
